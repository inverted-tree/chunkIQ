#![allow(non_snake_case)]

mod chunker;
mod parse;
mod trace;

use clap::{Parser, Subcommand, ValueEnum};
use std::{path::PathBuf, usize};

#[derive(Parser)]
#[command(
    version,
    about = "Measure and analyze file systems to find internal and temporal redundancy for file-based chunking and fingerprint-based data de-duplication.",
    long_about = None,
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    #[command(
        about = "Scan files and record chunk-level metadata",
        long_about = "The trace mode processes files using a specified chunking algorithm, computes chunk hashes (e.g., for content-defined or static-size chunks), and writes a metadata trace. This trace can later be analyzed to detect redundancy and estimate compression."
    )]
    Trace(TraceArgs),
    #[command(
        about = "Parse a chunking trace file and print a report",
        long_about = "The parse mode processes the trace file generated by the trace command. It reads the chunk-level metadata and produces a report on file system redundancy, chunk frequency, and potential compression opportunities. This mode can also be used to visualize temporal patterns, detect duplicates, and help assess the effectiveness of the chunking strategy."
    )]
    Parse(ParseArgs),
}

#[derive(ValueEnum, Clone, Copy, Debug)]
enum ChunkerType {
    SC2K,
    SC4K,
    SC8K,
    SC16K,
    SC32K,
    SC64K,
    CDC2K,
    CDC4K,
    CDC8K,
    CDC16K,
    CDC32K,
    CDC64K,
}

impl ChunkerType {
    fn getSize(&self) -> usize {
        match self {
            ChunkerType::SC2K => 1 << 11,
            ChunkerType::SC4K => 1 << 12,
            ChunkerType::SC8K => 1 << 13,
            ChunkerType::SC16K => 1 << 14,
            ChunkerType::SC32K => 1 << 15,
            ChunkerType::SC64K => 1 << 16,
            ChunkerType::CDC2K => 1 << 11,
            ChunkerType::CDC4K => 1 << 12,
            ChunkerType::CDC8K => 1 << 13,
            ChunkerType::CDC16K => 1 << 14,
            ChunkerType::CDC32K => 1 << 15,
            ChunkerType::CDC64K => 1 << 16,
        }
    }
}

#[derive(ValueEnum, Clone, Copy, Debug)]
enum HashType {
    SHA1,
    SHA256,
    MD5,
}

#[derive(Parser, Debug)]
struct TraceArgs {
    #[arg(
        short = 'c',
        long = "chunker",
        help = "Specify the chunking method (default = CDC8K)",
        value_enum
    )]
    chunkerTypes: Vec<ChunkerType>,

    #[arg(
        long = "digest",
        help = "Which hash function gets used by the chunker",
        value_enum,
        default_value_t = HashType::SHA1
    )]
    digestType: HashType,

    #[arg(short = 'L', long = "follow-symlinks", help = "Follow symbolic links")]
    followSymlinks: bool,

    #[arg(long = "full-paths", help = "Always log absolute file paths")]
    logRealPaths: bool,

    #[arg(
        short = 'j',
        long = "jobs",
        help = "How many parallel jobs to run (default = #cores)"
    )]
    jobs: Option<usize>,

    #[arg(
        short = 'l',
        long = "listing",
        help = "Treat the input file as a file listing"
    )]
    fileIsListing: bool,

    #[arg(
        long = "log-fingerprints",
        help = "Include chunk fingerprints in the log"
    )]
    logFingerprints: bool,

    #[arg(
        short = 'o',
        long = "output",
        name = "FILE",
        help = "Redirect output to a file"
    )]
    outputFile: Option<PathBuf>,

    #[arg(
        short = 'H',
        long = "hash-filenames",
        help = "Replace filenames in the log with hashes for privacy"
    )]
    hashFilenames: bool,

    #[arg(
        short = 'I',
        long = "report-interval",
        name = "INTERVAL",
        help = "Print a status report every <INTERVAL> seconds",
        default_value = "60"
    )]
    reportInterval: u32,

    #[arg(
        short = 'r',
        long = "recursive",
        help = "Recursively descent into subdirectories"
    )]
    recursive: bool,

    #[arg(
        short = 'R',
        long = "resume",
        name = "LOG_FILE",
        help = "Resume an aborted job from a progress file"
    )]
    progressFile: Option<PathBuf>,

    #[arg(
        long = "salt",
        name = "HASH_SALT",
        help = "Initialize the hashing function with this salt"
    )]
    hashSalt: Option<String>,

    #[arg(
        short = 's',
        long = "silent",
        help = "Suppress output and log messages"
    )]
    silent: bool,

    #[arg(required = true, help = "Input files or directories to process")]
    fileNames: Vec<PathBuf>,
}

impl TraceArgs {
    fn validate(&mut self) -> Result<(), String> {
        if self.chunkerTypes.is_empty() {
            self.chunkerTypes.push(ChunkerType::CDC8K);
        }
        self.jobs
            .get_or_insert(std::thread::available_parallelism().unwrap().get());
        if let Some(ref file) = self.progressFile {
            if !file.exists() {
                return Err(format!("Progress File {:?} does not exist", file));
            }
        }
        let ref files = self.fileNames;
        for file in files {
            if !file.exists() {
                return Err(format!("Input file {:?} does not exist", file));
            }
        }

        Ok(())
    }
}

#[derive(Parser, Debug)]
struct ParseArgs {
    #[arg(
        short = 'o',
        long = "output",
        name = "FILE",
        help = "Redirect output to a file"
    )]
    output: Option<PathBuf>,

    #[arg(
        short = 'I',
        long = "report-interval",
        name = "INTERVAL",
        help = "Print a status report every <INTERVAL> seconds",
        default_value = "60"
    )]
    reportInterval: Option<u32>,

    #[arg(required = true, help = "Trace files to process")]
    fileNames: Vec<PathBuf>,
}

impl ParseArgs {
    fn validate(&mut self) -> Result<(), String> {
        self.reportInterval.get_or_insert(60);

        Ok(())
    }
}

fn main() {
    let cli: Cli = Cli::parse();

    match cli.command {
        Commands::Parse(mut args) => match args.validate() {
            Ok(()) => parse::parser::run(&args),
            Err(e) => eprintln!("[Error] {}", e),
        },
        Commands::Trace(mut args) => match args.validate() {
            Ok(()) => match trace::tracer::run(&args) {
                Ok(_) => {}
                Err(_) => {}
            },
            Err(e) => eprintln!("[Error] {}", e),
        },
    }
}
