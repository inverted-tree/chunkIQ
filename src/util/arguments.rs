use crate::chunker::chunker::ChunkerType;
use clap::{Parser, Subcommand, ValueEnum};
use std::{path::PathBuf, usize};

#[derive(Parser)]
#[command(
    version,
    about = "Measure and analyze file systems to find internal and temporal redundancy for file-based chunking and fingerprint-based data de-duplication.",
    long_about = None,
)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    #[command(
        about = "Scan files and record chunk-level metadata",
        long_about = "The trace mode processes files using a specified chunking algorithm, computes chunk hashes (e.g., for content-defined or static-size chunks), and writes a metadata trace. This trace can later be analyzed to detect redundancy and estimate compression."
    )]
    Trace(TraceArgs),
    #[command(
        about = "Parse a chunking trace file and print a report",
        long_about = "The parse mode processes the trace file generated by the trace command. It reads the chunk-level metadata and produces a report on file system redundancy, chunk frequency, and potential compression opportunities. This mode can also be used to visualize temporal patterns, detect duplicates, and help assess the effectiveness of the chunking strategy."
    )]
    Parse(ParseArgs),
}

#[derive(ValueEnum, Clone, Copy, Debug)]
pub enum HashType {
    SHA1,
    SHA256,
    MD5,
}

#[derive(Parser, Debug)]
pub struct TraceArgs {
    #[arg(
        short = 'c',
        long = "chunker",
        help = "Specify the chunking method (default = CDC8K)",
        value_enum
    )]
    pub chunkerTypes: Vec<ChunkerType>,

    #[arg(
        short = 'd',
        long = "digest",
        help = "Which hash function is used to digest the chunks",
        value_enum,
        default_value_t = HashType::SHA1
    )]
    pub hashType: HashType,

    #[arg(short = 'L', long = "follow-symlinks", help = "Follow symbolic links")]
    pub followSymlinks: bool,

    #[arg(long = "full-paths", help = "Always log absolute file paths")]
    pub logRealPaths: bool,

    #[arg(
        short = 'j',
        long = "jobs",
        help = "How many parallel jobs to run (default = #cores)"
    )]
    pub jobs: Option<usize>,

    #[arg(
        short = 'l',
        long = "listing",
        help = "Treat the input file as a file listing"
    )]
    pub fileIsListing: bool,

    #[arg(
        long = "log-fingerprints",
        help = "Include chunk fingerprints in the log"
    )]
    pub logFingerprints: bool,

    #[arg(
        short = 'o',
        long = "output",
        name = "FILE",
        help = "Redirect output to a file"
    )]
    pub outputFile: Option<PathBuf>,

    #[arg(
        short = 'H',
        long = "hash-filenames",
        help = "Replace filenames in the log with hashes for privacy"
    )]
    pub hashFilenames: bool,

    #[arg(
        short = 'I',
        long = "report-interval",
        name = "INTERVAL",
        help = "Print a status report every <INTERVAL> seconds",
        default_value = "60"
    )]
    pub reportInterval: u32,

    #[arg(
        short = 'r',
        long = "recursive",
        help = "Recursively descent into subdirectories"
    )]
    pub recursive: bool,

    #[arg(
        short = 'R',
        long = "resume",
        name = "LOG_FILE",
        help = "Resume an aborted job from a progress file"
    )]
    pub progressFile: Option<PathBuf>,

    #[arg(
        long = "salt",
        name = "HASH_SALT",
        help = "Initialize the hashing function with this salt"
    )]
    pub hashSalt: Option<Box<str>>,

    #[arg(
        short = 's',
        long = "silent",
        help = "Suppress output and log messages"
    )]
    pub silent: bool,

    #[arg(required = true, help = "Input files or directories to process")]
    pub fileNames: Vec<PathBuf>,
}

impl TraceArgs {
    pub fn validate(&mut self) -> Result<(), String> {
        if self.chunkerTypes.is_empty() {
            self.chunkerTypes.push(ChunkerType::CDC8K);
        }
        if self.fileIsListing {
            self.fileNames = crate::util::fileIO::parseFileListings(
                self.fileNames.clone(),
                self.followSymlinks,
            )?;
        } else {
            self.fileNames =
                crate::util::fileIO::parseFiles(self.fileNames.clone(), self.followSymlinks)?;
        }
        self.jobs
            .get_or_insert(std::thread::available_parallelism().unwrap().get());
        if let Some(ref file) = self.progressFile {
            if !file.exists() {
                return Err(format!("Progress File {:?} does not exist", file));
            }
        }
        let ref files = self.fileNames;
        for file in files {
            if !file.exists() {
                return Err(format!("Input file {:?} does not exist", file));
            }
        }

        Ok(())
    }
}

#[derive(Parser, Debug)]
pub struct ParseArgs {
    #[arg(
        short = 'o',
        long = "output",
        name = "FILE",
        help = "Redirect output to a file"
    )]
    output: Option<PathBuf>,

    #[arg(
        short = 'I',
        long = "report-interval",
        name = "INTERVAL",
        help = "Print a status report every <INTERVAL> seconds",
        default_value = "60"
    )]
    reportInterval: Option<u32>,

    #[arg(required = true, help = "Trace files to process")]
    fileNames: Vec<PathBuf>,
}

impl ParseArgs {
    pub fn validate(&mut self) -> Result<(), String> {
        self.reportInterval.get_or_insert(60);

        Ok(())
    }
}
